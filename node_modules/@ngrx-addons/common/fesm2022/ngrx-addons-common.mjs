import { pipe, ReplaySubject, first, of } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from '@angular/core';
import { Injectable, APP_BOOTSTRAP_LISTENER, inject } from '@angular/core';

const createMergeReducer = (actionCheck) => (reducer) => (state, action) => {
    let newState = state;
    if (actionCheck(action)) {
        const { features } = action;
        newState = state ? { ...state } : {};
        Object.keys(features).forEach((key) => {
            newState[key] = {
                ...newState[key],
                ...features[key],
            };
        });
    }
    return reducer(newState, action);
};

/**
 * Exclude keys from the state
 */
const excludeKeys = (keys) => {
    return pipe(map((state) => Object.keys(state).reduce((toSave, key) => {
        if (!keys.includes(key)) {
            toSave[key] = state[key];
        }
        return toSave;
    }, {})));
};

/**
 * Include keys from the state
 */
const includeKeys = (keys) => {
    return pipe(map((state) => Object.keys(state).reduce((toSave, key) => {
        if (keys.includes(key)) {
            toSave[key] = state[key];
        }
        return toSave;
    }, {})));
};

/**
 * Check if states are equal
 */
const isEqual = (prev, next) => {
    if (prev === next) {
        return true;
    }
    if (!prev || !next || typeof prev !== 'object' || typeof next !== 'object') {
        return false;
    }
    const prevSlices = Object.keys(prev);
    const nextSlices = Object.keys(next);
    if (prevSlices.length !== nextSlices.length) {
        return false;
    }
    if (prevSlices.some((slice) => !isEqual(prev[slice], next[slice]))) {
        return false;
    }
    return true;
};

/**
 * Interface for strategies implementing way of initialization
 * of the state.
 */
class InitializationStrategy {
}
/**
 * Strategy initializing state after whole angular application is initialized.
 */
class AfterAppInit {
    #initialized = new ReplaySubject(1);
    when() {
        return this.#initialized.pipe(first());
    }
    /**
     * Mark strategy as initialized. Meant to be called once whole angular
     * application is initialized.
     */
    markAsInitialized() {
        this.#initialized.next();
    }
    /**
     * Cleanup resources.
     */
    ngOnDestroy() {
        this.#initialized.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: AfterAppInit, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: AfterAppInit, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: AfterAppInit, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
const afterAppInitProvider = {
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useFactory: (afterInit = inject(AfterAppInit)) => () => {
        afterInit.markAsInitialized();
    },
};
/**
 * Strategy initializing state as soon as it possible, before angular
 * application is initialized.
 */
class BeforeAppInit {
    when() {
        return of(void 0);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: BeforeAppInit, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: BeforeAppInit, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: BeforeAppInit, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AfterAppInit, BeforeAppInit, InitializationStrategy, afterAppInitProvider, createMergeReducer, excludeKeys, includeKeys, isEqual };
//# sourceMappingURL=ngrx-addons-common.mjs.map
