import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, NgModule, makeEnvironmentProviders, inject, ENVIRONMENT_INITIALIZER, Optional, SkipSelf } from '@angular/core';
import * as i3 from '@ngrx-addons/common';
import { isEqual, createMergeReducer, afterAppInitProvider, BeforeAppInit } from '@ngrx-addons/common';
import * as i1 from '@ngrx/store';
import { createAction, props, META_REDUCERS } from '@ngrx/store';
import { Subject, of, merge, from, filter, tap, defaultIfEmpty, map, distinctUntilChanged, skip, switchMap, takeUntil } from 'rxjs';

const REHYDRATE = '@ngrx-addons/persist-state/rehydrate';
const storeRehydrateAction = createAction(REHYDRATE, 
// eslint-disable-next-line @ngrx/prefer-inline-action-props
props());
const rehydrate = storeRehydrateAction;

class PersistStateRootConfig {
}
class PersistStateFeatureConfig {
}
/**
 * Injection token for the strategy used to initialize the state.
 */
const PersistStateStrategy = new InjectionToken('persist-state-init-strategy');
/**
 * Injection token for the list of states to persist.
 */
const PERSIST_STATE_FEATURE_CONFIGS = new InjectionToken('persist-state-feature-configs');
const ROOT_PERSIST_STORE = new InjectionToken('persist-state-root');
const FEATURE_PERSIST_STATE = new InjectionToken('persist-state-feature');

const rootState = 'root';
class PersistState {
    #rootConfig;
    #features = new Map();
    #destroyer = new Subject();
    constructor(store, strategy, rootConfig) {
        this.store = store;
        this.strategy = strategy;
        const { states, storageKeyPrefix, ...restConfig } = rootConfig;
        const keyPrefix = storageKeyPrefix ? `${storageKeyPrefix}-` : '';
        this.#rootConfig = { ...restConfig, storageKeyPrefix: keyPrefix, states };
    }
    addRoot() {
        const merged = this.#rootConfig.states?.map((state) => ({
            ...this.defaultStateConfig(state.key),
            ...state,
            key: state.key,
        })) ?? [];
        this.listenOnStates(merged, rootState).subscribe();
    }
    addFeature(feature) {
        if (this.#features.has(feature.key)) {
            return;
        }
        // Remove in case of re-adding
        this.removeFeature(feature.key);
        this.#features.set(feature.key, true);
        const merged = feature.states.map((state) => ({
            ...this.defaultStateConfig(feature.key),
            ...state,
            key: feature.key,
        }));
        this.listenOnStates(merged, feature.key).subscribe();
    }
    removeFeature(key) {
        this.#destroyer.next(key);
        this.#features.delete(key);
    }
    ngOnDestroy() {
        this.#features.forEach((_, key) => {
            this.removeFeature(key);
        });
        this.#destroyer.next(rootState);
        this.#destroyer.complete();
    }
    defaultStateConfig(key) {
        return {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            storageKey: `${this.#rootConfig.storageKeyPrefix}${key}@store`,
            source: (state) => state,
            runGuard: () => typeof window !== 'undefined',
            migrations: [],
            skip: 1,
        };
    }
    listenOnStates(states, feature) {
        if (states.length === 0) {
            return of(undefined);
        }
        return merge(...states.map((state) => {
            if (!state.runGuard()) {
                return of(undefined);
            }
            const storage = typeof state.storage === 'function' ? state.storage() : state.storage;
            return merge(
            // Restore state from storage
            this.rehydrateWhen(() => from(storage.getItem(state.storageKey))).pipe(filter((value) => !!value), tap((value) => {
                // Run migrations if defined
                if (state.migrations.length) {
                    value = this.runMigrations(value, state.migrations);
                }
                this.store.dispatch(rehydrate({ features: { [state.key]: value } }));
            }), defaultIfEmpty(undefined)), 
            // Save state to storage
            state
                .source(this.store.pipe(map((storeState) => storeState[state.key])))
                .pipe(distinctUntilChanged(isEqual), skip(state.skip), switchMap((value) => storage.setItem(state.storageKey, value))));
        })).pipe(takeUntil(this.#destroyer.pipe(filter((destroyFeature) => destroyFeature === feature))));
    }
    runMigrations(value, migrations) {
        migrations.forEach((migration) => {
            const version = value[(migration.versionKey ?? 'version')];
            if (migration.version === version) {
                value = migration.migrate(value);
            }
        });
        return value;
    }
    rehydrateWhen(input) {
        return this.strategy.when().pipe(switchMap(() => input()));
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistState, deps: [{ token: i1.Store }, { token: PersistStateStrategy }, { token: PersistStateRootConfig }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistState }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistState, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.Store }, { type: i3.InitializationStrategy, decorators: [{
                    type: Inject,
                    args: [PersistStateStrategy]
                }] }, { type: PersistStateRootConfig }] });

class PersistStateFeature {
    constructor(persistState, configs) {
        this.persistState = persistState;
        this.configs = configs;
    }
    addFeatures() {
        this.configs.forEach((config) => {
            this.persistState.addFeature(config);
        });
    }
    ngOnDestroy() {
        this.configs.forEach((config) => {
            this.persistState.removeFeature(config.key);
        });
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateFeature, deps: [{ token: PersistState }, { token: PERSIST_STATE_FEATURE_CONFIGS }], target: i0.ɵɵFactoryTarget.Injectable }); }
    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateFeature }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateFeature, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: PersistState }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PERSIST_STATE_FEATURE_CONFIGS]
                }] }] });

class PersistStateFeatureModule {
    constructor(state) {
        state.addFeatures();
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateFeatureModule, deps: [{ token: PersistStateFeature }], target: i0.ɵɵFactoryTarget.NgModule }); }
    /** @nocollapse */ static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.3", ngImport: i0, type: PersistStateFeatureModule }); }
    /** @nocollapse */ static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateFeatureModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateFeatureModule, decorators: [{
            type: NgModule
        }], ctorParameters: () => [{ type: PersistStateFeature }] });

const isRehydrateAction = (action) => action.type === REHYDRATE;
const persistStateReducer = createMergeReducer(isRehydrateAction);

const _providePersistStore = (config = {}) => {
    return [
        PersistState,
        { provide: PersistStateRootConfig, useValue: config },
        {
            provide: META_REDUCERS,
            useValue: persistStateReducer,
            multi: true,
        },
        afterAppInitProvider,
        {
            provide: PersistStateStrategy,
            useExisting: config.strategy ?? BeforeAppInit,
        },
    ];
};
const _providePersistState = (config) => {
    return [
        {
            provide: PERSIST_STATE_FEATURE_CONFIGS,
            useValue: config,
            multi: true,
        },
        PersistStateFeature,
    ];
};
/**
 * Persists the global store.
 * These providers cannot be used at the component level.
 *
 * @usageNotes
 *
 * ### Providing the global Persist Store
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [provideStore(), providePersistStore()],
 * });
 * ```
 */
const providePersistStore = (config = {}) => {
    return makeEnvironmentProviders([
        ..._providePersistStore(config),
        {
            provide: ROOT_PERSIST_STORE,
            useFactory: () => {
                inject(PersistState).addRoot();
            },
        },
        {
            provide: ENVIRONMENT_INITIALIZER,
            multi: true,
            useFactory: () => () => inject(ROOT_PERSIST_STORE),
        },
    ]);
};
/**
 * Persists additional slices of state.
 * These providers cannot be used at the component level.
 *
 * @usageNotes
 *
 * ### Persist Store Features
 *
 * ```ts
 * const booksRoutes: Route[] = [
 *   {
 *     path: '',
 *     providers: [provideState('books', booksReducer), providePersistState({ key: 'books' })],
 *     children: [
 *       { path: '', component: BookListComponent },
 *       { path: ':id', component: BookDetailsComponent },
 *     ],
 *   },
 * ];
 * ```
 */
const providePersistState = (config) => {
    return makeEnvironmentProviders([
        ..._providePersistState(config),
        {
            provide: FEATURE_PERSIST_STATE,
            useFactory: () => {
                inject(PersistStateFeature).addFeatures();
            },
        },
        {
            provide: ENVIRONMENT_INITIALIZER,
            multi: true,
            useFactory: () => () => inject(FEATURE_PERSIST_STATE),
        },
    ]);
};

class PersistStateRootModule {
    constructor(state, parentModule) {
        if (parentModule) {
            throw new Error('PersistStateRootModule is already loaded. Import it only once at AppModule!');
        }
        state.addRoot();
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateRootModule, deps: [{ token: PersistState }, { token: PersistStateRootModule, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.NgModule }); }
    /** @nocollapse */ static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.3", ngImport: i0, type: PersistStateRootModule }); }
    /** @nocollapse */ static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateRootModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateRootModule, decorators: [{
            type: NgModule
        }], ctorParameters: () => [{ type: PersistState }, { type: PersistStateRootModule, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }] });

class PersistStateModule {
    static forRoot(config = {}) {
        return {
            ngModule: PersistStateRootModule,
            providers: [..._providePersistStore(config)],
        };
    }
    static forFeature(config) {
        return {
            ngModule: PersistStateFeatureModule,
            providers: [..._providePersistState(config)],
        };
    }
    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    /** @nocollapse */ static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "18.0.3", ngImport: i0, type: PersistStateModule }); }
    /** @nocollapse */ static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.3", ngImport: i0, type: PersistStateModule, decorators: [{
            type: NgModule
        }] });

const noopStorage = {
    getItem: () => of(null),
    setItem: () => of(true),
    removeItem: () => of(true),
};
const createStorage = (storage) => {
    if (!storage) {
        return noopStorage;
    }
    return {
        getItem: (key) => {
            const v = storage.getItem(key);
            return of(v ? JSON.parse(v) : v);
        },
        setItem: (key, value) => {
            storage.setItem(key, JSON.stringify(value));
            return of(true);
        },
        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
        removeItem: (key) => {
            storage.removeItem(key);
            return of(true);
        },
    };
};
// we need to wrap the access to window.localStorage and window.sessionStorage in a try catch
// because localStorage can be disabled, or be denied by a security rule
// as soon as we access the property, it throws an error
const tryGetLocalStorage = () => {
    try {
        if (typeof localStorage !== 'undefined') {
            return localStorage;
        }
    }
    catch {
        // Ignore error
    }
    return undefined;
};
const localStorageStrategy = createStorage(tryGetLocalStorage());
const tryGetSessionStorage = () => {
    try {
        if (typeof sessionStorage !== 'undefined') {
            return sessionStorage;
        }
    }
    catch {
        // Ignore error
    }
    return undefined;
};
const sessionStorageStrategy = createStorage(tryGetSessionStorage());

/**
 * Generated bundle index. Do not edit.
 */

export { PersistState, PersistStateFeatureConfig, PersistStateFeatureModule, PersistStateModule, PersistStateRootConfig, PersistStateRootModule, REHYDRATE, createStorage, localStorageStrategy, providePersistState, providePersistStore, rehydrate, sessionStorageStrategy, storeRehydrateAction };
//# sourceMappingURL=ngrx-addons-persist-state.mjs.map
